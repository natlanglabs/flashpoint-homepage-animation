<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Gradient Circles with Swirling Colors</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Geist:wght@400;500&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: -0.02em;
        }

        /* White vignette overlay */
        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            background: radial-gradient(ellipse 70% 100% at center,
                transparent 0%,
                transparent 10%,
                rgba(255, 255, 255, 0.02) 18%,
                rgba(255, 255, 255, 0.06) 25%,
                rgba(255, 255, 255, 0.12) 32%,
                rgba(255, 255, 255, 0.22) 40%,
                rgba(255, 255, 255, 0.35) 48%,
                rgba(255, 255, 255, 0.5) 56%,
                rgba(255, 255, 255, 0.7) 64%,
                rgba(255, 255, 255, 0.85) 72%,
                rgba(255, 255, 255, 0.95) 80%,
                rgba(255, 255, 255, 1) 88%);
        }

        .container {
            width: 100%;
            height: 100%;
            position: relative;
            background: linear-gradient(to bottom, #FF0000 0%, #FF2000 50%, #FF4000 75%, #FF6000 100%);
            animation: backgroundShift 8s ease-in-out infinite;
            transition: filter 0.3s ease;
        }
        
        .container.typing {
            filter: brightness(1.15) saturate(1.2);
        }
        
        .color-boost-overlay {
            display: none;
        }
        
        .container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                transparent 40%, 
                rgba(255, 180, 100, 0) 50%,
                rgba(255, 180, 100, 0.3) 75%,
                rgba(255, 200, 120, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.8s ease;
            pointer-events: none;
        }
        
        .container.ring-active::after {
            opacity: 1;
        }

        #shaderCanvas {
            position: absolute;
            width: 700px;
            height: 700px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            opacity: 1;
        }

        .circle-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            height: 700px;
            z-index: 2;
            pointer-events: none;
        }

        .glow-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.6;
            background: radial-gradient(circle at center, 
                rgba(255, 255, 255, 0.8) 0%, 
                rgba(255, 220, 200, 0.5) 15%,
                rgba(255, 200, 150, 0.3) 30%, 
                rgba(255, 150, 100, 0.15) 45%,
                rgba(255, 100, 50, 0.05) 60%,
                transparent 75%);
            animation: pulse 4s ease-in-out infinite;
        }

        .cyan-ring {
            position: absolute;
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-radius: 50%;
            background: transparent;
            border: 25px solid #ffffff;
            box-shadow: 
                0 0 80px #ffffff,
                inset 0 0 80px #ffffff;
            animation: ringGlow 2s ease-in-out infinite alternate, ringRotate 20s linear infinite;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .cyan-ring.typing {
            transform: scale(1.05);
        }

        .center-orb {
            position: absolute;
            width: 50%;
            height: 50%;
            top: 25%;
            left: 25%;
            border-radius: 50%;
            background: radial-gradient(circle at center,
                rgba(255, 255, 255, 0.3) 0%,
                rgba(100, 180, 255, 0.2) 5%,
                rgba(50, 130, 255, 0.15) 15%,
                rgba(0, 80, 255, 0.1) 30%,
                rgba(0, 50, 200, 0.05) 50%,
                transparent 70%);
            filter: blur(15px);
            animation: orbFloat 6s ease-in-out infinite, orbPulse 4s ease-in-out infinite;
        }

        /* Search UI Styles */
        .search-container {
            position: absolute;
            top: 68%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100; /* Increased z-index to ensure it's above blur layers */
            width: 550px;
            height: auto;
            isolation: isolate; /* Create new stacking context */
        }

        .search-box {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            padding: 24px 28px 24px 28px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: none; /* Remove backdrop filter to avoid interaction with blur layers */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: relative; /* Ensure proper stacking */
        }

        .search-row {
            display: flex;
            align-items: center;
        }

        .search-icon {
            width: 20px;
            height: 20px;
            opacity: 0.4;
            flex-shrink: 0;
            margin-right: 12px;
        }

        .search-input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 16px;
            color: #666;
            outline: none;
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 400;
            letter-spacing: -0.02em;
        }

        .search-input::placeholder {
            color: #999;
            letter-spacing: -0.02em;
        }

        .action-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .left-action {
            display: flex;
            align-items: center;
        }

        .right-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .action-button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .action-button:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .action-button svg {
            width: 22px;
            height: 22px;
            opacity: 0.5;
        }

        .submit-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: #007AFF;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
            flex-shrink: 0;
        }

        .submit-button:hover {
            transform: scale(1.05);
            background: #0051D5;
        }

        .submit-button:active {
            transform: scale(0.95);
        }

        .submit-button svg {
            width: 24px;
            height: 24px;
            color: white;
            margin-left: 2px;
        }

        .suggestion-pills {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            padding-bottom: 4px;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .suggestion-pills::-webkit-scrollbar {
            display: none;
        }

        .suggestion-pill {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 16px;
            padding: 0 20px;
            height: 32px;
            font-size: 12pt;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: 'Geist', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            letter-spacing: -0.02em;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .suggestion-pill:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .suggestion-pill.orange {
            background: #FF5722;
            color: white;
        }

        .suggestion-pill.blue {
            background: #2196F3;
            color: white;
        }

        .suggestion-pill.dark {
            background: #424242;
            color: white;
        }

        .suggestion-icon {
            width: 16px;
            height: 16px;
        }

        /* Blur-proof layer for background only */
        .blur-target {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        @keyframes backgroundShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        @keyframes ringGlow {
            0% { 
                box-shadow: 
                    0 0 80px #ffffff,
                    inset 0 0 80px #ffffff;
                border-width: 25px;
            }
            100% { 
                box-shadow: 
                    0 0 100px #ffffff,
                    inset 0 0 100px #ffffff;
                border-width: 28px;
            }
        }

        @keyframes ringRotate {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.02); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(0.98); }
            100% { transform: rotate(360deg) scale(1); }
        }

        @keyframes orbFloat {
            0%, 100% { transform: translateY(0) scale(1); }
            33% { transform: translateY(-10px) scale(1.05); }
            66% { transform: translateY(10px) scale(0.95); }
        }

        @keyframes orbPulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Blur target layer -->
    <div class="blur-target">
        <!-- White vignette overlay -->
        <div class="vignette-overlay"></div>
        
        <div class="container">
            <div class="color-boost-overlay"></div>
            <canvas id="shaderCanvas"></canvas>
            
            <div class="circle-wrapper">
                <div class="glow-layer"></div>
                <div class="cyan-ring"></div>
                <div class="center-orb"></div>
            </div>
        </div>
    </div>

    <!-- Search UI - Outside blur target -->
    <div class="search-container">
        <div class="search-box">
            <!-- Row 1: Search icon and input -->
            <div class="search-row">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
                <input type="text" class="search-input" id="searchInput" placeholder="What do you want to ask your market?">
            </div>
            
            <!-- Row 2: Paperclip left, mic and arrow right -->
            <div class="action-row">
                <div class="left-action">
                    <button class="action-button">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                        </svg>
                    </button>
                </div>
                <div class="right-actions">
                    <button class="action-button">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" y1="19" x2="12" y2="23"></line>
                            <line x1="8" y1="23" x2="16" y2="23"></line>
                        </svg>
                    </button>
                    <button class="submit-button">
                        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                            <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebGL Shader Setup
        const canvas = document.getElementById('shaderCanvas');
        const gl = canvas.getContext('webgl', { 
            alpha: true,
            premultipliedAlpha: false 
        });
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = 700;
            canvas.height = 700;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        
        // Vertex shader source
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 vUv;
            void main() {
                vUv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        // Fragment shader source - deep, rich color palette
        const fragmentShaderSource = `
            precision mediump float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            varying vec2 vUv;
            
            // Custom tanh implementation
            float tanh(float x) {
                float e2x = exp(2.0 * clamp(x, -10.0, 10.0));
                return (e2x - 1.0) / (e2x + 1.0);
            }
            
            // Smooth minimum function for color blending
            float smin(float a, float b, float k) {
                float h = max(k - abs(a - b), 0.0) / k;
                return min(a, b) - h * h * h * k * (1.0 / 6.0);
            }
            
            void main() {
                vec2 uv = vUv;
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(uv, center);
                
                // Smooth fade that avoids dark edges
                float circleFade = 1.0 - smoothstep(0.2, 0.45, dist);
                
                vec2 p = (uv - 0.5) * 2.0;
                
                // Much slower mouse influence
                vec2 mouseNorm = u_mouse / u_resolution;
                float mouseInfluence = 1.0 - distance(uv, mouseNorm) * 2.0;
                mouseInfluence = max(0.0, mouseInfluence) * 0.3;
                
                // Create swirling motion
                float angle = length(p) * 4.0 + mouseInfluence * 0.5;
                mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                p *= rotation;
                
                float l = length(p) - 0.7 + mouseInfluence * 0.1;
                float t = u_time * 1.3 + mouseInfluence * 0.5;
                float enhancedY = p.y + mouseInfluence * 0.1;
                
                // Create flowing patterns with varied phase shifts
                float val1 = clamp(0.1 / max(l / 0.1, -l) - sin(l + enhancedY * max(1.0, -l / 0.1) + t), -3.0, 3.0);
                float val2 = clamp(0.1 / max(l / 0.1, -l) - sin(l + enhancedY * max(1.0, -l / 0.1) + t + 2.094), -3.0, 3.0);
                float val3 = clamp(0.1 / max(l / 0.1, -l) - sin(l + enhancedY * max(1.0, -l / 0.1) + t + 4.188), -3.0, 3.0);
                float val4 = clamp(0.1 / max(l / 0.1, -l) - sin(l + enhancedY * max(1.0, -l / 0.1) + t - 1.57), -3.0, 3.0);
                
                // Convert to 0-1 range with varied curves for more contrast
                float pattern1 = pow(0.5 + 0.5 * tanh(val1 * 2.0), 2.2);
                float pattern2 = pow(0.5 + 0.5 * tanh(val2 * 1.8), 1.8);
                float pattern3 = pow(0.5 + 0.5 * tanh(val3 * 2.2), 2.0);
                float pattern4 = pow(0.5 + 0.5 * tanh(val4 * 1.5), 1.5);
                
                // Define deep, rich colors matching reference images
                vec3 deepOrange = vec3(1.0, 0.1, 0.0);        // Maximum intensity orange
                vec3 richBurgundy = vec3(0.9, 0.0, 0.1);      // Very strong burgundy
                vec3 deepBlue = vec3(0.0, 0.05, 1.0);         // Pure vibrant blue
                vec3 royalBlue = vec3(0.0, 0.4, 1.0);         // Bright royal blue
                vec3 warmAmber = vec3(1.0, 0.4, 0.0);         // Intense amber
                vec3 deepPurple = vec3(0.6, 0.0, 0.9);        // Vivid purple
                vec3 lightAccent = vec3(1.0, 0.95, 1.0);      // Bright accent
                vec3 cyanAccent = vec3(0.2, 1.0, 1.0);        // Pure cyan
                
                // Create complex color mixing with occasional light accents
                vec3 color1 = mix(deepOrange, richBurgundy, pattern1);
                vec3 color2 = mix(deepBlue, royalBlue, pattern2);
                vec3 color3 = mix(deepPurple, warmAmber, pattern3);
                
                // Add occasional lighter accents based on pattern peaks
                float lightMix = smoothstep(0.7, 0.95, pattern4) * 0.6;
                color1 = mix(color1, mix(warmAmber, lightAccent, pattern1), lightMix * 0.4);
                color2 = mix(color2, cyanAccent, lightMix * pattern2 * 0.3);
                
                // Dynamic weighted blending
                float w1 = pattern1 * (1.0 + sin(t + l * 3.0) * 0.4);
                float w2 = pattern2 * (1.0 + cos(t * 1.3 - l * 2.0) * 0.4);
                float w3 = pattern3 * (1.0 + sin(t * 0.7 + l * 4.0) * 0.3);
                float w4 = pattern4 * 0.3; // Lighter weight for accent colors
                float totalW = w1 + w2 + w3 + 0.001;
                
                vec3 finalColor = (color1 * w1 + color2 * w2 + color3 * w3) / totalW;
                
                // Add depth with darker shadows in some areas
                float shadowPattern = sin(l * 5.0 + t * 0.8) * 0.5 + 0.5;
                finalColor *= 0.7 + shadowPattern * 0.5;
                
                // Boost saturation for richer colors
                float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));
                finalColor = mix(vec3(luminance), finalColor, 4.0); // Even higher saturation
                
                // Add subtle color shifts
                finalColor += vec3(
                    sin(uv.x * 3.14159 + t * 0.5) * 0.1,
                    cos(uv.y * 3.14159 - t * 0.3) * 0.1,
                    sin((uv.x + uv.y) * 2.0 + t * 0.4) * 0.12
                );
                
                // Final adjustments - maximum brightness boost
                finalColor = pow(finalColor, vec3(0.65)) * 1.7;
                finalColor = clamp(finalColor, 0.0, 1.0);
                
                // Full opacity in center, smooth fade at edges
                float alpha = circleFade;
                
                gl_FragColor = vec4(finalColor * alpha, alpha);
            }
        `;
        
        // Create and compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        // Create shader program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }
        
        // Set up geometry (full screen quad)
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
        
        // Mouse tracking with much slower interpolation
        let mouseX = 300;
        let mouseY = 300;
        let currentMouseX = 300;
        let currentMouseY = 300;
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        
        // Animation loop
        let startTime = Date.now();
        function render() {
            // Much slower mouse interpolation
            currentMouseX += (mouseX - currentMouseX) * 0.02;
            currentMouseY += (mouseY - currentMouseY) * 0.02;
            
            // Clear with transparent background
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            
            // Set uniforms
            const time = (Date.now() - startTime) / 1000;
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform2f(mouseLocation, currentMouseX, currentMouseY);
            
            // Set up position attribute
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        // Enable proper alpha blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        render();
        
        // Simplified blur effect - only applies to blur-target
        let currentX = window.innerWidth / 2;
        let currentY = window.innerHeight / 2;
        let targetX = currentX;
        let targetY = currentY;
        let animationFrame = null;
        
        let glowX = window.innerWidth / 2;
        let glowY = window.innerHeight / 2;
        
        // Idle animation variables
        let lastMouseMove = Date.now();
        let idleRotation = 0;
        let isIdle = false;
        const IDLE_TIMEOUT = 2000;
        const IDLE_SPEED = 0.5;

        function createRadialBlurLayers() {
            const existingRadialBlur = document.querySelector('.radial-gradient-blur');
            if (existingRadialBlur) {
                existingRadialBlur.remove();
            }

            const radialBlur = document.createElement('div');
            radialBlur.className = 'radial-gradient-blur';
            radialBlur.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 3;
            `;

            const blurConfigs = [
                { blur: 4, innerClear: 80, outerFade: 200 },
                { blur: 12, innerClear: 120, outerFade: 300 },
                { blur: 24, innerClear: 180, outerFade: 450 },
                { blur: 36, innerClear: 250, outerFade: 600 }
            ];
            
            blurConfigs.forEach((config, index) => {
                const div = document.createElement('div');
                div.className = `blur-layer-${index}`;
                div.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    backdrop-filter: blur(${config.blur}px);
                    -webkit-backdrop-filter: blur(${config.blur}px);
                    z-index: ${index + 1};
                    transition: backdrop-filter 0.3s ease;
                `;
                div.dataset.baseBlur = config.blur;
                div.dataset.innerClear = config.innerClear;
                div.dataset.outerFade = config.outerFade;
                radialBlur.appendChild(div);
            });

            // Insert the blur layers inside the blur-target div, not body
            const blurTarget = document.querySelector('.blur-target');
            blurTarget.appendChild(radialBlur);
            return radialBlur;
        }
        
        function createBackgroundGlow() {
            const glowLayer = document.createElement('div');
            glowLayer.className = 'background-glow';
            glowLayer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
                opacity: 0;
                mix-blend-mode: screen;
                transition: opacity 0.5s ease;
            `;
            
            const glowGradient = document.createElement('div');
            glowGradient.className = 'glow-gradient';
            glowGradient.style.cssText = `
                position: absolute;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle at center,
                    rgba(100, 150, 255, 0.15) 0%,
                    rgba(50, 100, 255, 0.08) 20%,
                    rgba(20, 60, 200, 0.05) 40%,
                    transparent 70%);
                filter: blur(80px);
                transform: scale(2);
            `;
            
            glowLayer.appendChild(glowGradient);
            // Insert inside blur-target, not body
            const blurTarget = document.querySelector('.blur-target');
            blurTarget.insertBefore(glowLayer, blurTarget.firstChild);
            
            setTimeout(() => {
                glowLayer.style.opacity = '1';
            }, 100);
            
            return glowGradient;
        }

        const radialBlurContainer = createRadialBlurLayers();
        const backgroundGlow = createBackgroundGlow();

        function updateRadialMasks(mouseX, mouseY) {
            const blurLayers = radialBlurContainer.querySelectorAll('[class^="blur-layer-"]');
            
            blurLayers.forEach((layer) => {
                const baseBlur = parseFloat(layer.dataset.baseBlur);
                const innerClear = parseInt(layer.dataset.innerClear);
                const outerFade = parseInt(layer.dataset.outerFade);
                
                layer.style.backdropFilter = `blur(${baseBlur}px)`;
                layer.style.webkitBackdropFilter = `blur(${baseBlur}px)`;
                
                const mask = `radial-gradient(circle at ${mouseX}px ${mouseY}px,
                    transparent ${innerClear}px,
                    black ${outerFade}px
                )`;
                
                layer.style.mask = mask;
                layer.style.webkitMask = mask;
            });
        }

        function animate() {
            const currentTime = Date.now();
            const timeSinceMove = currentTime - lastMouseMove;
            
            if (timeSinceMove > IDLE_TIMEOUT && !isIdle) {
                isIdle = true;
                const cyanRing = document.querySelector('.cyan-ring');
                const rect = cyanRing.getBoundingClientRect();
                const ringCenterX = rect.left + rect.width / 2;
                const ringCenterY = rect.top + rect.height / 2;
                const ringRadius = rect.width / 2 - 30;
                
                const dx = currentX - ringCenterX;
                const dy = currentY - ringCenterY;
                idleRotation = Math.atan2(dy, dx) * (180 / Math.PI);
            }
            
            if (isIdle) {
                const cyanRing = document.querySelector('.cyan-ring');
                const rect = cyanRing.getBoundingClientRect();
                const ringCenterX = rect.left + rect.width / 2;
                const ringCenterY = rect.top + rect.height / 2;
                const ringRadius = rect.width / 2 - 30;
                
                idleRotation += IDLE_SPEED;
                if (idleRotation > 360) idleRotation -= 360;
                
                const angleRad = idleRotation * (Math.PI / 180);
                targetX = ringCenterX + Math.cos(angleRad) * ringRadius;
                targetY = ringCenterY + Math.sin(angleRad) * ringRadius;
            }
            
            const lerpFactor = isIdle ? 0.05 : 0.03;
            const glowLerpFactor = isIdle ? 0.03 : 0.02;
            
            currentX += (targetX - currentX) * lerpFactor;
            currentY += (targetY - currentY) * lerpFactor;
            
            glowX += (targetX - glowX) * glowLerpFactor;
            glowY += (targetY - glowY) * glowLerpFactor;
            
            updateRadialMasks(currentX, currentY);
            updateBackgroundGlow(glowX, glowY);
            
            const threshold = 0.5;
            if (isIdle || 
                Math.abs(targetX - currentX) > threshold || 
                Math.abs(targetY - currentY) > threshold ||
                Math.abs(targetX - glowX) > threshold ||
                Math.abs(targetY - glowY) > threshold) {
                animationFrame = requestAnimationFrame(animate);
            } else {
                currentX = targetX;
                currentY = targetY;
                glowX = targetX;
                glowY = targetY;
                updateRadialMasks(currentX, currentY);
                updateBackgroundGlow(glowX, glowY);
                animationFrame = null;
            }
        }
        
        function updateBackgroundGlow(x, y) {
            if (!backgroundGlow) return;
            
            const xPercent = (x / window.innerWidth) * 100;
            const yPercent = (y / window.innerHeight) * 100;
            
            backgroundGlow.style.background = `radial-gradient(circle at ${xPercent}% ${yPercent}%,
                rgba(100, 150, 255, 0.15) 0%,
                rgba(50, 100, 255, 0.08) 20%,
                rgba(20, 60, 200, 0.05) 40%,
                transparent 70%)`;
        }

        document.addEventListener('mousemove', (e) => {
            targetX = e.clientX;
            targetY = e.clientY;
            
            lastMouseMove = Date.now();
            isIdle = false;
            
            if (!animationFrame) {
                animationFrame = requestAnimationFrame(animate);
            }
        });

        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            targetX = touch.clientX;
            targetY = touch.clientY;
            
            lastMouseMove = Date.now();
            isIdle = false;
            
            if (!animationFrame) {
                animationFrame = requestAnimationFrame(animate);
            }
        });

        document.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            targetX = touch.clientX;
            targetY = touch.clientY;
            
            lastMouseMove = Date.now();
            isIdle = false;
            
            if (!animationFrame) {
                animationFrame = requestAnimationFrame(animate);
            }
        });

        updateRadialMasks(currentX, currentY);
        updateBackgroundGlow(glowX, glowY);
        
        animationFrame = requestAnimationFrame(animate);
        
        // Ring interaction system
        const cyanRing = document.querySelector('.cyan-ring');
        const container = document.querySelector('.container');
        let isMouseInRing = false;
        
        function isPointInRing(x, y) {
            const rect = cyanRing.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            
            const outerRadius = rect.width / 2;
            
            return distance < outerRadius;
        }
        
        document.addEventListener('mousemove', (e) => {
            const wasInRing = isMouseInRing;
            isMouseInRing = isPointInRing(e.clientX, e.clientY);
            
            if (isMouseInRing && !wasInRing) {
                container.classList.add('ring-active');
            } else if (!isMouseInRing && wasInRing) {
                container.classList.remove('ring-active');
            }
        });
        
        // Auto-focus and simple typing effects
        window.addEventListener('load', () => {
            const searchInput = document.getElementById('searchInput');
            const container = document.querySelector('.container');
            const cyanRing = document.querySelector('.cyan-ring');
            
            // Auto-focus on the input field
            setTimeout(() => {
                searchInput.focus();
            }, 500);
            
            // Simple typing effects
            searchInput.addEventListener('input', (e) => {
                if (e.target.value.length > 0) {
                    // Add typing classes when there's content
                    container.classList.add('typing');
                    cyanRing.classList.add('typing');
                } else {
                    // Remove typing classes when empty
                    container.classList.remove('typing');
                    cyanRing.classList.remove('typing');
                }
            });
            
            // Keep effects on blur if there's content
            searchInput.addEventListener('blur', () => {
                if (searchInput.value.length === 0) {
                    container.classList.remove('typing');
                    cyanRing.classList.remove('typing');
                }
            });
            
            // Re-apply effects on focus if there's content
            searchInput.addEventListener('focus', () => {
                if (searchInput.value.length > 0) {
                    container.classList.add('typing');
                    cyanRing.classList.add('typing');
                }
            });
        });
    </script>
</body>
</html>